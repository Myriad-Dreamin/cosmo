
pub class ValueT(T: Type) {
  case Null
  case Bool(bool)
  case NumberSigned(i64)
  case NumberUnsigned(u64)
  case Number(f64)
  case String(String)
  case Array(Vec(Self))
  case Object(Map(String, Self))
  case _ =>
    import T.{value, parse};

    def length = self match {
      case Array(v) | Object(v) => Ok(v.length)
      case _ => Err("Value is not an array or object");
    }

    def apply(implicit Ty: Type, self, index: Ty) = if (Ty == usize) self match {
      case Array(arr) => Ok(arr(index))
      case _ => Err("Value is not an array");
    } else if (Ty == String) self match {
      case Object(obj) => Ok(obj(index))
      case _ => Err("Value is not an object");
    } else Err("Invalid index type");

    /// == Example
    ///
    /// ```cos
    /// self(0)
    /// key
    /// self("key")
    /// self.key
    /// key(0)
    /// self("self")
    /// self.key(0)
    /// ```
    def path(implicit S: syntax.Expr, self, field: S) = S match {
      case syntax.Expr.Apply(syntax.Expr.Self, field) | syntax.Expr.Ident(field) => std.code {
        self.apply(field)
      }
      case syntax.Expr.Apply(field, index) => std.code {
        self.apply(field).andThen(_.value.apply(index))
      }
      case syntax.Expr.Select(target, field) => std.code {
        self.path(target)
      }
      case _ => panic("path is not valid");
    }
}

import "nlohmann/json.hpp" as nlohmann;

def NlohmannJsonValue = nlohmann.json.value;
def NlohmannJsonTag: std.c.enum(u8) = nlohmann.json.value_t;

class NlohmannJsonImpl {
  var internal: NlohmannJsonValue;
  lazy def value: ValueT(Self) = Self.from(internal);
  def parse(implicit Ty: Type, s: Ty) = {
    assert(Ty == String, "Only string parsing is supported for NlohmannJsonImpl");
    // todo: panic?
    Self.from(nlohmann.json.parse(s))
  }
  def getAs(Ty: Type): T = unsafe internal.externalCall(cpp, s"get<${Ty.cppName}>()");
  def from(j: NlohmannJsonValue) = unsafe j.m_type: NlohmannJsonTag match {
    case NlohmannJsonTag.null => ValueT(Self).Null
    case NlohmannJsonTag.boolean => ValueT(Self).Bool(j.getAs(bool))
    case NlohmannJsonTag.number_integer => ValueT(Self).NumberSigned(j.getAs(i64))
    case NlohmannJsonTag.number_unsigned => ValueT(Self).NumberUnsigned(j.getAs(u64))
    case NlohmannJsonTag.number_float => ValueT(Self).Number(j.getAs(f64))
    case NlohmannJsonTag.string => ValueT(Self).String(j.getAs(String))
    case NlohmannJsonTag.array => ValueT(Self).Array(j.getAs(Vec(NlohmannJsonValue)).map(Self(internal = _)))
    case NlohmannJsonTag.object => ValueT(Self).Object(j.getAs(Map(NlohmannJsonValue)).map(Self(internal = _)))
    case _ => panic(s"Invalid JSON type ${j.m_type}");
  }
}

// default JSON implementation
pub def Value = ValueT(NlohmannJsonImpl);

pub def parse(implicit Ty: Type, s: Ty) = Value.parse(s);
