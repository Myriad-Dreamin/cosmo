
import "@lib/c++/cctype"
import stringSys from "@lib/c++/string"
import stringViewSys from "@lib/c++/string_view"

pub def CppString: Type = stringSys.std.string
pub def CppStringView: Type = stringViewSys.std.string_view

pub class Rune {
  var internal: u32;
}

pub class String {
  var internal: CppString = stringSys.std.string();
}

pub class str {
  var internal: CppStringView = stringViewSys.std.string_view();
}

pub class Bytes {
  var internal: CppString = stringSys.std.string();
}

code("""
inline bool operator<(const String &lhs, const String &rhs) {
  return lhs.internal < rhs.internal;
}
inline bool operator<(const Bytes &lhs, const Bytes &rhs) {
  return lhs.internal < rhs.internal;
}
inline bool operator==(const Rune &lhs, const Rune &rhs) {
  return lhs.internal == rhs.internal;
}

template <> struct DisplayTrait<Rune> {
  static void print(const Rune &x) {
    if (x.internal < 0x80 && std::isprint(x.internal)) {
      printf("'%c'", x.internal);
    } else {
      printf("c\"\\u{%x}\"", x.internal);
    }
  }
};
template <> struct DisplayTrait<String> {
  static void print(const String &x) { printf("%s", x.internal.c_str()); }
};
template <> struct DisplayTrait<Bytes> {
  static void print(const Bytes &x) {
    printf("b\"");
    for (char c : x.internal) {
      printf("\\x%02x", (unsigned char)c);
    }
    printf("\"");
  }
};
""")