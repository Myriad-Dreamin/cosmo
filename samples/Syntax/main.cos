
@external
def Vec(Ty: Type) = cxx.std.vector(Ty);

def Source /* inferred as : Type */ = class {
  val data = Vec(u8)
}
def Pair(Lhs: Type, Rhs: Type) /* inferred as : Type */ = (Lhs, Rhs);

trait Unsigned(T: Type) {
  assert(T == u8 or T == u16 or T == u32 or T == u64);
  def asUint64(self): u64 = self;
  // or
  val asUint64 = method(Identity(u64));
}

def UnsignedVec(T: Type) = {
  assert(Unsigned(T));
}
// or
def UnsignedVec(T: Unsigned(T)) = _;

def DependentType(T: Type) = if (T == u8) {
  u16
} else {
  u32
}

// Enum class will be translated into tagged union
class Nat {
  case Zero
  case Succ(Nat)
}

val succ = nat.map {
  case Zero
  case Succ(succ: Nat) => succ
}

val hasSucc = nat.map {
  case Zero => 0
  case Succ(Nat) => 1
}

val hasSucc = nat match {
  case Zero => 0
  case Succ(Nat) => 1
}


def add(A: Nat, B: Nat): Nat = A match {
  case Zero => B
  case Succ(B) => Succ(Add(A, B))
}

// implicit type parameters are inferred automatically
val identity(implicit T: Type)(val v: T) = Identity;
val lift(implicit T: Type)(val v: T) = Type;

// partial specialization
val identityU8 = identity(implicit u8);

val True = Type(true);

// equivalent to
def conditionalPrint(msg: String) = {
  if (Type(true)) { // compile-time evaluation
    println(msg);
  }
}

 // compile-time value
val EnableLogging = True;

def conditionalPrint(msg: String) = {
  if (EnableLogging) {
    println(msg);
  }
}

var runtimeEnableLogging = false;

def conditionalPrintWithRuntime(msg: String) = {
  // it should be evaluated at compile-time, but some of which can only be evaluated at runtime
  // Use `lift` to mix them.
  val enableLogging = EnableLogging or lift(runtimeEnableLogging);
  if (enableLogging) {
    println(msg);
  }
}

def main(): () = {
  val x = 1
  val y = 2
  val z = x + y
  println(z)
}

def catchException(implicit T)(f: () => T): T = {
  trait ExceptionHandler {
    def (excp: Exception): Nothing;
  }

  def neverFail(excp) = panic(excp.toString());

  handleThrow(ExceptionHandler, neverFail);
  f();
}

def catchFuture(implicit T)(f: () => Promise(T)): T = {
  trait PromiseHandler {
    def (promise: Promise(T)): T;
  }

  val futureExecutor: PromiseHandler = cxx.std.launch;

  handleThrow(PromiseHandler, futureExecutor);
  f();
}

def main() {
  def readFile(filename: String): Promise(String);
  catchException(() => {
    catchFuture(() => {
      val fileContent = throw readFile("file.txt");
      println(fileContent);
    });
  });
}

// compile features are enabled by type or string
@feature(Ref = "v1") {
  def Referential(implicit A: Ref)(T: Type) = class {
    val pointer: Ref(A, Vec(T));
  }
}

def Referential(implicit A: Ref)(T: Type) = class {
  val pointer: Ref(A, Vec(T));
}

def case1() { // ok
  var elem = Vec(u32)(0);
  var r = Referential;
  r.pointer = elem;
} // elem destroyed

def case2() { // error
  var r = Referential;
  {
    var elem = Vec(u32)(0);
    r.pointer = elem;
  } // elem destroyed
}


def case3() { // ok
  var a = Alloc();
  var r = Referential;
  {
    var elem = a.allocate(Vec(u32))(0);
    r.pointer = elem;
  }
} // elem destroyed

def case4() { // error
  var r = Referential;
  {
    var a = Alloc();
    {
      var elem = a.allocate(Vec(u32))(0);
      r.pointer = elem;
    }
  } // elem destroyed
}

def SelfReferential(implicit val A: Ref)(T: Type) = class {
  val pointer: Ref(A, Vec(T));
}

def case1() { // ok
  var elem = Vec(u32)(0);
  var r = SelfReferential;
  r.pointer = elem;
} // elem destroyed

def case2() { // ok
  var r = SelfReferential;
  {
    var elem = Vec(u32)(0);
    r.pointer = elem;
  }
} // elem destroyed

def case3(elem: Ref(Vec(u32))) { // error: cannot lift elem2 to outer scope
  var r = SelfReferential;
  r.pointer = elem;
  {
    var elem2 = Vec(u32)(0);
    r.pointer = elem2;
  }
}

def case4() { // ok
  var r = SelfReferential;
  var elem2 = Vec(u32)(0);
  r.pointer = elem2;
  return r;
}

val Static = Alloc();
val StaticReferential = SelfReferential(implicit Static);

def case1() { // ok
  var r = StaticReferential;
  {
    var elem = Vec(u32)(0);
    r.pointer = elem;
  }
}

def case2() { // null pointer exception, since static references will be checked at runtime
  var r = StaticReferential;
  {
    var elem = Vec(u32)(0);
    r.pointer = elem;
    drop(elem);
    r.pointer(0) = 1;
  }
}

def case3() { // SIGSEGV, since static references checking is bypassed
  var r = StaticReferential;
  unsafe {
    var elem = Vec(u32)(0);
    r.pointer = elem;
    drop(elem);
    r.pointer.unchecked(0) = 1;
  }
}
