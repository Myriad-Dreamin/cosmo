//! This file is automatically generated by copilot.

package cosmo.syntax

def toJson(node: Node): String = {
  var buf = new StringBuilder
  j(node, buf)
  buf.toString
}

type NodeKinds = Node | No | Ident | Str | Boolean | BigInt | BigDecimal |
  List[Node]
private def jpol(node: Pol, buf: StringBuilder): Unit = {
  if node.isEmpty then buf.append("null")
  else j(node.get, buf)
}
private def j(node: NodeKinds, buf: StringBuilder): Unit = {
  node match {
    case n: No      => if n.isEmpty then buf.append("null") else j(n.get, buf)
    case s: Str     => buf.append(s""""$s"""")
    case b: Boolean => buf.append(b)
    case i: BigInt  => buf.append(i.toString)
    case d: BigDecimal => buf.append(d.toString)
    case l: List[Node] => {
      buf.append("[")
      var first = true
      l.foreach { node =>
        if !first then buf.append(","); first = false
        j(node, buf)
      }
      buf.append("]")
    }

    case Self       => buf.append("""{"kind": "self"}""")
    case BigSelf    => buf.append("""{"kind": "bigself"}""")
    case TodoLit    => buf.append("""{"kind": "todo"}""")
    case Semi(None) => buf.append("""{"kind": "semi"}""")
    case Semi(Some(node)) =>
      buf.append("""{"kind": "semi", "value": """)
      j(node, buf)
      buf.append("}")
    case Ident(name)    => buf.append(s"""{"kind": "ident", "name": "$name"}""")
    case BoolLit(value) => buf.append(s"""{"kind": "bool", "value": $value}""")
    case IntLit(value)  => buf.append(s"""{"kind": "int", "value": "$value"}""")
    case FloatLit(value) =>
      buf.append(s"""{"kind": "float", "value": "$value"}""")
    case StringLit(value) =>
      buf.append(s"""{"kind": "string", "value": "$value"}""")
    case Block(stmts) =>
      buf.append("""{"kind": "block", "stmts": """)
      j(stmts, buf)
      buf.append("}")
    case Val(name, ty, init) =>
      buf.append("""{"kind": "val", "name": """)
      j(name, buf)
      buf.append(""", "ty": """)
      j(ty, buf)
      buf.append(""", "init": """)
      j(init, buf)
      buf.append("}")
    case Var(name, ty, init) =>
      buf.append("""{"kind": "var", "name": """)
      j(name, buf)
      buf.append(""", "ty": """)
      j(ty, buf)
      buf.append(""", "init": """)
      j(init, buf)
      buf.append("}")
    case Typ(name, ty, init) =>
      buf.append("""{"kind": "typ", "name": """)
      j(name, buf)
      buf.append(""", "ty": """)
      j(ty, buf)
      buf.append(""", "init": """)
      j(init, buf)
      buf.append("}")
    case Class(name, params, body) =>
      buf.append("""{"kind": "class", "name": """)
      j(name, buf)
      buf.append(""", "params": """)
      jpol(params, buf)
      buf.append(""", "body": """)
      j(body, buf)
      buf.append("}")
    case Trait(name, params, body) =>
      buf.append("""{"kind": "trait", "name": """)
      j(name, buf)
      buf.append(""", "params": """)
      jpol(params, buf)
      buf.append(""", "body": """)
      j(body, buf)
      buf.append("}")
    case Param(name, ty, init) =>
      buf.append("""{"kind": "param", "name": """)
      j(name, buf)
      buf.append(""", "ty": """)
      j(ty, buf)
      buf.append(""", "init": """)
      j(init, buf)
      buf.append("}")
    case Def(name, params, ret, rhs) =>
      buf.append("""{"kind": "def", "name": """)
      j(name, buf)
      buf.append(""", "params": """)
      jpol(params, buf)
      buf.append(""", "ret": """)
      j(ret, buf)
      buf.append(""", "rhs": """)
      j(rhs, buf)
      buf.append("}")
    case Import(path, dest) =>
      buf.append("""{"kind": "import", "path": """)
      j(path, buf)
      buf.append(""", "dest": """)
      j(dest, buf)
      buf.append("}")
    case Loop(body) =>
      buf.append("""{"kind": "loop", "body": """)
      j(body, buf)
      buf.append("}")
    case For(name, iter, body) =>
      buf.append("""{"kind": "for", "name": """)
      j(name, buf)
      buf.append(""", "iter": """)
      j(iter, buf)
      buf.append(""", "body": """)
      j(body, buf)
      buf.append("}")
    case Break()    => buf.append("""{"kind": "break"}""")
    case Continue() => buf.append("""{"kind": "continue"}""")
    case If(cond, cont_bb, else_bb) =>
      buf.append("""{"kind": "if", "cond": """)
      j(cond, buf)
      buf.append(""", "cont_bb": """)
      j(cont_bb, buf)
      buf.append(""", "else_bb": """)
      j(else_bb, buf)
      buf.append("}")
    case UnOp(op, lhs) =>
      buf.append("""{"kind": "unop", "op": """)
      j(op, buf)
      buf.append(""", "lhs": """)
      j(lhs, buf)
      buf.append("}")
    case BinOp(op, lhs, rhs) =>
      buf.append("""{"kind": "binop", "op": """)
      j(op, buf)
      buf.append(""", "lhs": """)
      j(lhs, buf)
      buf.append(""", "rhs": """)
      j(rhs, buf)
      buf.append("}")
    case Match(lhs, rhs) =>
      buf.append("""{"kind": "match", "lhs": """)
      j(lhs, buf)
      buf.append(""", "rhs": """)
      j(rhs, buf)
      buf.append("}")
    case As(lhs, rhs) =>
      buf.append("""{"kind": "as", "lhs": """)
      j(lhs, buf)
      buf.append(""", "rhs": """)
      j(rhs, buf)
      buf.append("}")
    case Select(lhs, rhs) =>
      buf.append("""{"kind": "select", "lhs": """)
      j(lhs, buf)
      buf.append(""", "rhs": """)
      j(rhs, buf)
      buf.append("}")
    case Apply(lhs, rhs) =>
      buf.append("""{"kind": "apply", "lhs": """)
      j(lhs, buf)
      buf.append(""", "rhs": [""")
      j(rhs, buf)
      buf.append("]}")
    case TmplApply(lhs, rhs) =>
      buf.append("""{"kind": "tmplapply", "lhs": """)
      j(lhs, buf)
      buf.append(""", "rhs": [""")
      var first = true
      rhs.foreach { arg =>
        if !first then buf.append(",")
        first = false
        buf.append("""{"name": """)
        j(arg._1, buf)
        buf.append(""", "value": """)

        if arg._2.isEmpty then buf.append("null")
        else
          for (v <- arg._2) {
            buf.append("""{"kind": "tmplapply", "lhs": """)
            j(v._1, buf)
            buf.append(""", "rhs": [""")
            var first = true
            v._2.foreach { arg =>
              if !first then buf.append(",")
              j(arg, buf)
            }
            buf.append("]}")
          }

        buf.append("}")
      }
      buf.append("]}")
    case KeyedArg(key, value) =>
      buf.append("""{"kind": "keyedarg", "key": """)
      j(key, buf)
      buf.append(""", "value": """)
      j(value, buf)
      buf.append("}")
    case Return(value) =>
      buf.append("""{"kind": "return", "value": """)
      j(value, buf)
      buf.append("}")
    case CaseBlock(stmts) =>
      buf.append("""{"kind": "caseblock", "stmts": [""")
      j(stmts, buf)
      buf.append("]}")
    case Case(cond, body) =>
      buf.append("""{"kind": "case", "cond": """)
      j(cond, buf)
      buf.append(""", "body": """)
      j(body, buf)
      buf.append("}")
  }
}
